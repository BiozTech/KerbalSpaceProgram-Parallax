// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain2

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct ObjectData
{
    float3 pos;
    //float4 rot;
    float3 scale;
};
struct GrassData
{
    float4x4 mat;
    float4 color;
};
struct Triangle
{
    int index;
};
RWStructuredBuffer<ObjectData> Objects;
RWStructuredBuffer<GrassData> Grass;
RWStructuredBuffer<Triangle> Tris;

float4x4 objectToWorld;
float seed = 1;
float _Range = 60;
int populationMult = 1;
int indexLength = 11;
float PI = 3.141592654;
float _ColorDeviationStrength = 0.5;

float Random01(float2 uv)
{
    float rnd = frac(sin(dot(uv, float2(12.9898, 78.233))) * 43758.5453123);
    return rnd;
}
float DegToRad(float deg)
{
    return (3.14159 / 180.0f) * deg;
}
float4x4 GetTranslationMatrix(float3 pos)
{
    return  float4x4(float4(1, 0, 0, pos.x), float4(0, 1, 0, pos.y), float4(0, 0, 1, pos.z), float4(0,0,0,1));//
}
float4x4 GetRotationMatrix(float3 anglesDeg)
{
    anglesDeg = float3(DegToRad(anglesDeg.x), DegToRad(anglesDeg.y), DegToRad(anglesDeg.z));

    float4x4 rotationX = 
        float4x4(float4(1, 0, 0, 0),
        float4(0, cos(anglesDeg.x), -sin(anglesDeg.x), 0),
        float4(0, sin(anglesDeg.x), cos(anglesDeg.x), 0),
        float4(0, 0, 0, 1));

    float4x4 rotationY = 
        float4x4(float4(cos(anglesDeg.y), 0, sin(anglesDeg.y), 0),
        float4(0, 1, 0, 0),
        float4(-sin(anglesDeg.y), 0, cos(anglesDeg.y), 0),
        float4(0, 0, 0, 1));

    float4x4 rotationZ = 
        float4x4(float4(cos(anglesDeg.z), -sin(anglesDeg.z), 0, 0),
        float4(sin(anglesDeg.z), cos(anglesDeg.z), 0, 0),
        float4(0, 0, 1, 0),
        float4(0, 0, 0, 1));

    return mul(rotationY, mul(rotationX, rotationZ));
}
float4x4 GetScaleMatrix(float3 scale)
{
    return  float4x4(float4(scale.x, 0, 0, 0),
            float4(0, scale.y, 0, 0),
            float4(0, 0, scale.z, 0),
            float4(0, 0, 0, 1));
}
float4x4 GetTRSMatrix(float3 position, float3 rotationAngles, float3 scale)
{
    return mul(GetTranslationMatrix(position), mul(GetRotationMatrix(rotationAngles), GetScaleMatrix(scale)));
}
[numthreads(1,1,1)]
void CSMain2 (uint3 id : SV_DispatchThreadID)
{
    float3 craftPos = mul(objectToWorld, float4(0, 0, 0, 1)).xyz;
    float3 vertexPos = mul(objectToWorld, float4((Objects[id.x].pos.xyz + Objects[id.x + 1].pos.xyz + Objects[id.x + 2].pos.xyz) / 3, 1)).xyz;
    float range = distance(craftPos, vertexPos);
    float rangePerc = saturate(range / _Range);
    //populationMult *= rangePerc;
    for (int i = 0; i < populationMult; i++)
    {
        float3 scale = float3(1, 1, 1) * rangePerc;

        int index1 = Tris[id.x * 3].index;
        int index2 = Tris[id.x * 3 + 1].index;
        int index3 = Tris[id.x * 3 + 2].index;

        float3 pos1 = Objects[index1].pos;
        float3 pos2 = Objects[index2].pos;
        float3 pos3 = Objects[index3].pos;

        float r1 = Random01(id.xy + 1 + i);
        float r2 = Random01(float2(id.x, r1) + 1 * 1.23133 + i);

        

        float3 pos = ((1 - sqrt(r1)) * pos1) + ((sqrt(r1) * (1 - r2)) * pos2) + ((r2 * sqrt(r1)) * pos3);
        
        float r3 = Random01(pos.xz * 0.2);

        float3 rot = float3(0,0,0);
        //scale = float3(1, (1 + r3) * 1, 1);
        pos = mul(objectToWorld, float4(pos.xyz, 1)).xyz;

        //float range = distance(craftPos, pos);
        //if (range > _Range)
        //{
        //    scale = float3(0, 0, 0);
        //}

        float4x4 mat = GetTRSMatrix(pos, rot, scale);
        float colorDeviation = ((r3 - 0.5) * 2) * _ColorDeviationStrength;

        //mat = mat * objectToWorld;
        GrassData newGrass;
        newGrass.mat = mat;// float4x4(float4(1, 0, 0, pos.x), float4(0, 1, 0, pos.y), float4(0, 0, 1, pos.z), float4(0, 0, 0, pos.w));
        newGrass.color = float4(1, 1, 1, 1) + colorDeviation;
        Grass[id.x * populationMult + i] = newGrass;
    }
}

